(window.webpackJsonp=window.webpackJsonp||[]).push([[117],{493:function(t,a,r){"use strict";r.r(a);var s=r(7),o=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-配置tomcat后台管理系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-配置tomcat后台管理系统"}},[t._v("#")]),t._v(" 1.配置Tomcat后台管理系统")]),t._v(" "),a("p",[a("strong",[t._v("tomcat8：")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://fire-repository.oss-cn-beijing.aliyuncs.com/performance/tomcat/manager.png",alt:""}})]),t._v(" "),a("p",[a("strong",[t._v("tomcat7：")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://fire-repository.oss-cn-beijing.aliyuncs.com/performance/tomcat/config.png",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"_2-动静分离"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-动静分离"}},[t._v("#")]),t._v(" 2.动静分离")]),t._v(" "),a("p",[t._v("静态资源如果让 Tomcat 处理的话 Tomcat 的性能会被损耗很多，\n所以我们一般都是采用：Nginx+Tomcat 实现动静分离，让Tomcat只负责Java文件的解析工作，Nginx实现静态资源的访问。")]),t._v(" "),a("h2",{attrs:{id:"_3-tomcat线程池调优"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-tomcat线程池调优"}},[t._v("#")]),t._v(" 3.Tomcat线程池调优")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://fire-repository.oss-cn-beijing.aliyuncs.com/performance/tomcat/tomcat-thread.png",alt:""}})]),t._v(" "),a("ul",[a("li",[t._v("name：给执行器（线程池）起一个名字；")]),t._v(" "),a("li",[t._v("namePrefix：指定线程池中的每一个线程的 name 前缀；")]),t._v(" "),a("li",[t._v("maxThreads：线程池中最大的线程数量，假设请求的数量超过了 750，这将不是意味着将 maxThreads 属性值设置为 750，它的最好解决方案是使用「Tomcat集群」。也就是说，如果有 1000 请求，两个 Tomcat 实例设置 maxThreads = 500，而不在单 Tomcat 实例的情况下设置 maxThreads=1000。")]),t._v(" "),a("li",[t._v("minSpareThreads：线程池中允许空闲的线程数量（多余的线程都杀死）；")]),t._v(" "),a("li",[t._v("maxIdLeTime：一个线程空闲多久算是一个空闲线程；")])]),t._v(" "),a("p",[a("strong",[t._v("管理界面")]),t._v(" "),a("img",{attrs:{src:"https://fire-repository.oss-cn-beijing.aliyuncs.com/performance/tomcat/web.png",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"_4-修改tomcat的运行模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-修改tomcat的运行模式"}},[t._v("#")]),t._v(" 4.修改Tomcat的运行模式")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://fire-repository.oss-cn-beijing.aliyuncs.com/performance/tomcat/nio.png",alt:""}})]),t._v(" "),a("ul",[a("li",[t._v("BIO")])]),t._v(" "),a("p",[t._v("Tomcat8 以下版本，默认使用的就是 BIO「阻塞式IO)」模式。\n对于每一个请求都要创建一个线程来进行处理，不适合高并发。")]),t._v(" "),a("ul",[a("li",[t._v("NIO")])]),t._v(" "),a("p",[t._v("Tomcat8 以上版本，默认使用的就是NIO模式「非阻塞式 IO」。")]),t._v(" "),a("h2",{attrs:{id:"_5-禁用-ajp连接器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-禁用-ajp连接器"}},[t._v("#")]),t._v(" 5.禁用 AJP连接器")]),t._v(" "),a("p",[t._v("AJP的全称 Apache JServer Protocol，使用 Nginx+Tomcat的架构，所以用不着 AJP 协议，所以把AJP连接器禁用。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://fire-repository.oss-cn-beijing.aliyuncs.com/performance/tomcat/jap.png",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"_6-jvm调优"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-jvm调优"}},[t._v("#")]),t._v(" 6.JVM调优")]),t._v(" "),a("p",[t._v("Tomcat 是运行在 JVM 上的，所以对 JVM 的调优也是非常有必要的。")]),t._v(" "),a("p",[t._v("在catalina.sh中配置JVM参数，这里不做过多阐述")])])}),[],!1,null,null,null);a.default=o.exports}}]);